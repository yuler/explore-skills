# 富 Web 应用的 7 条原则

**作者：** [Guillermo Rauch](https://rauchg.com/)  
**原文：** [7 principles of rich web applications](https://rauchg.com/2014/7-principles-of-rich-web-applications)  
**发表日期：** 2014 年 11 月 4 日

---

本文基于 2014 年 8 月我在 BrazilJS 上的演讲整理而成，延续了我近期在博客中关于 UX 与性能的一些想法。

我想为那些希望用 JavaScript 控制 UI 的网站，提出 7 条可执行的原则。它们来自我作为 Web 开发者的经验，也来自我长期使用万维网的体会。

JavaScript 无疑已成为前端开发者的必备工具，其使用范围正扩展到[服务端](http://nodejs.org/)和[微控制器](https://tessel.io/)等领域，也是知名大学[讲授计算机科学](http://web.stanford.edu/class/cs101/)时常用的语言。

然而，关于它在 Web 上的确切角色和用法，仍有不少疑问，甚至很多框架和库的作者也不清楚：

* JavaScript 是否应该取代浏览器的历史、导航和页面渲染？
* 后端是否在消亡？是否还需要渲染 HTML？
* 单页应用（SPA）是否是未来？
* JS 在网站上是否只应增强页面，而在 Web 应用中负责渲染页面？
* 是否应该使用 PJAX 或 TurboLinks 这类技术？
* 网站与 Web 应用的确切区别是什么？是否需要有区别？

下面是我对这些问题的回答。我的思路是**仅从用户体验（UX）**的角度审视 JavaScript 的使用，尤其关注**缩短用户获取感兴趣数据所需的时间**，从网络基础一直到对未来的展望。

## 目录

1. [预渲染页面不可或缺](#1-预渲染页面不可或缺)
2. [对用户输入立即响应](#2-对用户输入立即响应)
3. [对数据变化做出反应](#3-对数据变化做出反应)
4. [掌控与服务器的数据交换](#4-掌控与服务器的数据交换)
5. [不要破坏历史，而是增强它](#5-不要破坏历史而是增强它)
6. [推送代码更新](#6-推送代码更新)
7. [预测行为](#7-预测行为)

---

## 1. 预渲染页面不可或缺

⚡️ 预渲染不只是为了 SEO，更是为了性能。要考虑获取脚本、样式以及后续 API 请求带来的额外往返。未来可考虑 HTTP/2 的“推送”资源。

*注：此标题曾为“服务端渲染”。但“预渲染”也涵盖[静态站点生成](https://rauchg.com/2020/2019-in-review#static-is-the-new-dynamic)，故已改为现用表述。*

首先要澄清一个常见的二元对立：**“预渲染/服务端渲染应用 vs 单页应用”**。若以最佳用户体验和性能为目标，放弃其中任一方都不是好选择。

原因很直接。页面赖以传输的媒介——互联网——存在理论上的速度上限。Stuart Cheshire 在著名文章 [《是延迟，笨蛋》](http://www.stuartcheshire.org/rants/latency.html) 中形象地说明过：

> 斯坦福到波士顿约 4320 公里。  
> 真空中光速约 300×10⁶ m/s。  
> 光纤中光速约为真空的 66%。  
> 单程延迟约 21.6ms，往返约 43.2ms。  
> 如今斯坦福到波士顿的 ping 约 85ms……

波士顿与斯坦福之间约 85ms 的往返时间会随时间改善，你现在的测试可能已经更好，但重要的是：**两岸之间理论最低延迟大约在 50ms 左右**。

用户连接的带宽可以明显提升，但**延迟几乎不会大幅改善**。因此，**减少“为在页面上展示信息而进行的往返次数”**，对体验和响应速度至关重要。

这一点在“由 JavaScript 驱动、除 `<script>` 和 `<link>` 外只有空 `<body>`”的应用兴起后尤其重要。这类应用被称为“单页应用”（SPA）：服务器始终只返回一页，其余都由客户端代码完成。

设想用户通过链接或输入 URL 访问 `http://app.com/orders/`。当应用收到并处理请求时，**已经知道**将要展示什么，例如可以从数据库预取订单并放进响应。而在多数 SPA 中，返回的是空白页和一个 `<script>` 标签，需要再一轮往返获取脚本，然后再一轮获取渲染所需的数据。

许多开发者会刻意接受这种取舍：通过为脚本和样式设置合适的缓存头，让这些额外的网络请求只发生一次。普遍看法是：一旦资源包加载完，后续大部分交互（如页面切换）不再需要新页面或新脚本，因此可以接受。

但即便有缓存，**脚本的解析与执行**仍会带来性能损耗。[《jQuery 对移动端是否过大？》](http://modernweb.com/2014/03/10/is-jquery-too-big-for-mobile/) 指出，仅 jQuery 在某些移动浏览器上就可能需要数百毫秒。更糟的是，脚本加载期间往往**没有任何反馈**，用户看到的是空白页，然后突然变成完整页面。

尤其要记住：当前主流的互联网传输协议（TCP）**启动很慢**。多数脚本包无法在一次往返内取回，上述情况会进一步恶化。

TCP 以一次握手的往返开始；若使用 SSL（对安全交付脚本很重要），还会多出两次往返（若客户端恢复会话则只多一次）。之后服务器才能开始发数据，而且会**缓慢、逐步**地发。TCP 内置的**慢启动**机制会以逐渐增多的**段**发送数据，对 SPA 有两点影响：

1. **大脚本的实际下载时间比看起来长得多**。Ilya Grigorik 在 [《高性能浏览器网络》](http://chimera.labs.oreilly.com/books/1230000000545/ch02.html#thats_four_rou) 中写道：在客户端与服务器之间达到 64 KB 吞吐量需要“四次往返……以及数百毫秒延迟”。在伦敦到纽约的优质连接下，TCP 也要约 225ms 才能达到最大包大小。
2. **首屏内容因此格外重要**。Paul Irish 在 [《Delivering the Goods》](https://docs.google.com/presentation/d/1MtDBNTH1g7CZzhwlJ1raEJagA8qM3uoV7ta6i66bO2M/present#slide=id.g3eb97ca8f_10) 中总结：**前 14KB 至关重要**。

能在这一窗口内交付内容（哪怕只是基础布局、不含数据）的网站，会显得非常灵敏。事实上，很多快速服务端应用的作者会认为 JavaScript 不必用或应少用，若后端快、数据源近、服务器靠近用户（CDN），这种倾向更强。

服务器在加速内容呈现上的角色因应用而异，并不总是“在服务端渲染整页”那么简单。有时，非首屏或非关键部分更适合从首屏响应中排除，由客户端稍后拉取。例如只渲染页面“壳”以尽快响应，再并行拉取不同区块，即便后端较慢也能保持良好响应。对部分页面，只预渲染“首屏”内容也是可行方案。

根据服务器掌握的会话、用户和 URL 信息，**对脚本和样式做定性评估**非常关键。处理订单排序的脚本对 `/orders` 显然比设置页逻辑更重要；同样可以区分“结构 CSS”和“皮肤/主题 CSS”——前者可能被 JS 依赖，应阻塞加载，后者可异步加载。

一个不增加额外往返的 SPA 例子是 [《4096 字节内的 StackOverflow》](http://danlec.com/blog/stackoverflow-in-4096-bytes) 的概念验证（理论上可在 TCP 握手后的第一次往返内交付），代价是把所有资源内联进响应、牺牲可缓存性。借助 [SPDY 或 HTTP/2 服务端推送](http://www.chromium.org/spdy/link-headers-and-server-hint)，理论上可以在单次往返内交付可缓存的客户端代码。目前，在服务端渲染部分或全部页面仍是避免额外往返的最常见做法。

足够灵活、能在浏览器与服务器间共享渲染代码，并支持渐进加载脚本与样式的系统，很可能会消除“网站”与“Web 应用”的俗成区分——二者都遵循同样的 UX 原则。博客和 CRM 在本质上差别不大：都有 URL、导航、向用户展示数据。即便是传统上更依赖客户端的电子表格，也首先要**用最少网络往返**把用户要修改的数据展示出来。

在我看来，当前许多广泛部署的系统在性能上的主要取舍，来自技术栈复杂度的逐步累积。JavaScript、CSS 是逐步加入的，其流行度也在逐步上升，现在我们才能更清楚不同用法带来的影响。协议改进（如 SPDY、QUIC）会解决一部分问题，但**应用层**才是大部分收益的来源。

可以参考早期 WWW 与 HTML 设计的一些讨论来理解这一点，尤其是 [1997 年邮件列表中关于在 HTML 中加入 `<img>` 的讨论](http://1997.webhistory.org/www.lists/www-talk.1993q1/0260.html)。Marc Andreessen 重申了快速呈现信息的重要性：

> “如果文档需要动态拼装，可能会变得任意复杂，即便加以限制，我们也会在性能上遭受重大损失。这基本上把 **WWW 的单跳原则** 抛在脑后（IMG 也违背了，但是出于非常具体、有限的原因）——我们确定要这么做吗？”

---

## 2. 对用户输入立即响应

⚡️ JavaScript 可以完全掩盖网络延迟。把这一点作为设计原则，甚至能去掉大部分“加载中”和转圈。PJAX 或 TurboLinks 会错过很多提升“感觉速度”的机会。

第一原则的核心是：**尽量减少用户与网站交互时的延迟**。

即便如此，有些事无法完全控制：用户与服务器之间的物理距离带来的理论下界无法突破；网络质量差或不稳定也会导致重传，本应几次往返的请求可能变成很多次。

而 JavaScript 在提升 UX 上的最大优势正在于此：**用客户端代码驱动交互，我们可以“掩盖”延迟**，制造“很快”的感知，在体验上逼近零延迟。

回顾一下传统 HTML Web：通过超链接（`<a>`）串起的文档，点击后浏览器发起不可预测时长的请求，收到响应后再切换状态。

JavaScript 允许我们**立即、乐观地**响应用户输入。点击链接或按钮可以在不访问网络的情况下立刻有反馈。典型例子是 Gmail（或 Google Inbox）：归档邮件时 UI 立即更新，请求在后台异步发送和处理。

对于表单，我们不必等提交后返回的 HTML，可以在用户按回车后立刻响应；或像 Google 搜索那样，在用户按键时就开始响应。

这种行为是我所说的**布局适配**：当前页“知道”下一状态的布局，因此可以在拿到数据之前就切换过去。之所以是“乐观”，是因为仍有数据不到或出错的可能，但这种情况较少。

Google 首页与本文特别相关，因为它清晰体现了前两条原则。首先，对 `www.google.com` 的 [TCP 抓包](https://gist.github.com/rauchg/3e1b2d7529009370b986) 显示，请求到达后他们会一次性发完整个首页；在旧金山，整个交互（含关闭连接）约 64ms，这很可能 [从很早就是这样](http://en.wikipedia.org/wiki/Google#mediaviewer/File:Google1998.png)。2004 年底，Google [率先](http://googleblog.blogspot.com/2004/12/ive-got-suggestion.html) 用 JavaScript 做输入时的即时建议（有趣的是作为 20% 项目，类似 Gmail），这也成为 [AJAX 一词的灵感](http://www.adaptivepath.com/ideas/ajax-new-approach-web-applications/)：

> 看看 Google Suggest，建议词会随着输入几乎即时更新……无需等待整页重载。Google Suggest 和 Google Maps 是我们所说的 Ajax 新思路的两个例子。

2010 年他们又 [推出](http://googleblog.blogspot.com/2010/09/search-now-faster-than-speed-of-type.html) 即时搜索，把 JS 放在中心：完全跳过整页刷新，一按键就切换到“搜索结果”布局。

另一个典型的布局适配例子很可能就在你口袋里。从早期起，iPhone OS 就要求应用提供 `default.png`，在应用真正加载前先显示这张图——这里补偿的不一定是网络延迟，而是 CPU，在当年硬件条件下很重要。这种技巧在布局与存储图片不一致时会失效，例如登录屏；[Marco Arment 在 2010 年](http://www.marco.org/2010/11/11/my-default-png-dilemma) 对此做过分析。

除点击和表单提交外，**文件输入**也是被 JavaScript 渲染大大增强的一类输入。我们可以通过拖放、粘贴、文件选择器捕获上传意图，然后借助 [HTML5 文件 API](https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications) 在“上传完成前”就展示内容，例如 Cloudup 的上传：缩略图会立即生成并显示。

以上都在增强“速度感”。有充分证据表明这是好做法，例如 [增加前往行李提取区的步行距离](http://www.nytimes.com/2012/08/19/opinion/sunday/why-waiting-in-line-is-torture.html) 减少了休斯顿机场的投诉，而实际行李处理并没有变快。

把这一思路贯彻到 UI 上，会带来深远影响。我认为转圈和“加载中”应尽量少用，尤其在下一节讨论的**实时数据**应用中。

有些场景下，“立刻完成”的错觉反而有害，例如支付表单或登出链接。在这些地方乐观地告诉用户“已经完成”会带来糟糕体验。即便如此，**转圈和加载提示也应延后出现**——只有在用户已经觉得响应不够即时之后才显示。根据 [Nielsen 的经典研究](http://www.nngroup.com/articles/response-times-3-important-limits/)：

> **0.1 秒**：用户感觉系统在即时响应，通常只需展示结果，无需额外反馈。  
> **1.0 秒**：用户思维流大致不会被打断，但会注意到延迟。**超过 0.1 秒、不足 1 秒时通常不需要特别反馈**，但用户会失去“直接操作数据”的感觉。  
> **10 秒**：大约是可保持用户专注的上限；再长用户会想做别的事。

遗憾的是，PJAX 或 TurboLinks 很难充分利用本节所说的机会：在完成一整轮服务端往返之前，客户端代码并不“知道”下一页长什么样。

---

## 3. 对数据变化做出反应

⚡️ 服务器上的数据变了，应主动通知客户端，而不是等客户端来问。这是一种“性能”改进：用户不必再手动刷新（F5、下拉刷新）。新挑战：连接/重连管理、状态协调。

第三原则是：UI 应**对数据源（通常是一个或多个数据库）的变化做出反应**。

“返回一份静态的 HTML 快照，直到用户刷新或通过 AJAX 交互才更新”的模式越来越过时。**你的 UI 应该是自更新的**。

在设备数量不断增多（手表、手机、平板和尚未出现的可穿戴设备）的今天，这一点尤其重要。

想想 Facebook 信息流诞生之初，数据主要来自个人电脑。当时静态渲染虽不完美，但若人们可能一天才更新一次资料，还说得过去。现在，你上传一张照片，同伴几乎马上就能点赞或评论，**实时反馈**因应用的高度并发使用而变得自然。

但不能认为“响应式”只对多用户应用有用。我更喜欢说**并发的数据点**而不是“用户”。例如常见的场景：把手机上的照片同步到自己的笔记本。

不妨把用户能接触到的所有数据都视为可响应的。**会话与登录状态同步**就是统一应用这一原则的例子：若用户同时开着多个标签，在其中一个登出会使全部失效，从而提升隐私与安全，尤其在多人共用设备时。

一旦你建立了“屏幕上的信息会自动更新”的预期，就需要考虑一个新需求：**状态协调**。

在按序接收原子数据更新时，很容易忽略：应用在**长时间断线后**也应能正确更新。例如合上笔记本几天后再打开，应用应如何表现？

能够协调“时间上脱节”的状态，也与第一原则相关：若在首屏加载时带上数据，必须考虑数据在网络上传输、直到客户端脚本加载完成的这段时间——本质上等同于一次断线，脚本的首次连接则是会话恢复。

---

## 4. 掌控与服务器的数据交换

⚡️ 我们现在可以精细控制与服务器的数据交换。要妥善处理错误、替用户重试、在后台同步、维护离线缓存。

WWW 诞生时，客户端与服务器的数据交换方式很有限：

* 点击链接 → `GET` 新页面并渲染  
* 提交表单 → `POST` 或 `GET` 并渲染新页面  
* 嵌入图片或对象 → 异步 `GET` 并渲染  

这一模型的简洁很吸引人，今天我们在理解“数据如何收发”上的学习曲线无疑更高了。

最大限制在第二点：**无法在不必整页刷新的情况下发送数据**，对性能不利，更糟的是**后退按钮会完全失效**。

没有 JavaScript，Web 作为**应用平台**几乎不可想象。AJAX 在“用户提交信息”的体验上是一次**跨越**。

现在我们有一系列 API（`XMLHttpRequest`、`WebSocket`、`EventSource` 等）可以精细控制数据流。除了把用户输入的数据发出去，我们还有新机会提升 UX。

与上一原则特别相关的是：**展示连接状态**。若数据会自动更新，就应告知用户**已断线**以及**正在重连**。

检测到断线时，把数据存到内存（或更好的 `localStorage`）以便稍后发送很有用。[Service Worker](http://jakearchibald.com/2014/using-serviceworker-today/) 的引入让 Web 应用能在**后台**运行；即使应用未打开，也可以在后台尝试同步用户数据。

发送数据时要考虑超时与错误，**替用户重试**：连接恢复后再次发送；若持续失败，再告知用户。

某些错误需特别处理。例如意外的 `403` 可能表示会话已失效，此时可以弹出登录页让用户重新登录。

还要避免用户无意中打断数据流。一种情况是关闭浏览器或标签，可以用 `beforeunload` 做一定防护；另一种是点击会触发整页加载的链接，应在跳转前拦截，以便显示自己的确认弹窗等。

---

## 5. 不要破坏历史，而是增强它

⚡️ 一旦由我们而非浏览器管理 URL 与历史，新问题就会出现。不要破坏与滚动相关的预期，并维护自己的缓存以提供快速反馈。

若不考虑表单提交，仅用超链接设计现代 Web 应用，我们会得到可用的前进/后退导航。

例如典型的“无限滚动”：常见做法是用 JavaScript 拦截点击、请求数据/HTML、插入内容。是否调用 `history.pushState` 或 `replaceState` 往往是可选的，而很多人没有做。

所以我用“破坏”这个词：在早期 Web 的简单模型里，本没有这种状况——每次状态变化都对应 URL 变化。

反过来，既然能用 JavaScript 控制历史，也就有了**增强**历史的机会。其中之一是 Daniel Pipius 提出的 [Fast Back](https://medium.com/joys-of-javascript/beyond-pushstate-building-single-page-applications-4353246f4480)：

> 后退应该很快；用户不会预期数据有太大变化。

这相当于把后退当作应用级按钮，并应用原则 2：对用户输入立即响应。关键是你可以决定如何缓存上一页并立即渲染，然后再应用原则 3，告知用户该页发生的**新**数据变化。

有些情况下你无法完全控制缓存。例如：先渲染一页，再跳转到第三方站，用户点后退。在服务端渲染 HTML、再在客户端修改的应用，尤其容易遇到这种微妙问题。

另一种破坏导航的方式是忽略**滚动记忆**。不依赖 JS 和手动历史管理的页面大多没这个问题，但动态页面常有。我测试过 Twitter 和 Facebook 两个最流行的 JS 信息流，都表现出“滚动失忆”。

还要注意**仅与历史导航相关的状态**。例如切换评论子树的展开/折叠：若用户通过应用内链接重新进入该页，预期可能是所有评论都展开。该状态是**易失的**，只与历史栈中的那一条记录相关。

---

## 6. 推送代码更新

⚡️ 只推送数据而不推送代码是不够的。若数据会自动更新，代码也应能更新。避免 API 错误、提升性能。用无状态 DOM 实现无副作用的重绘。

让应用对**代码变更**做出反应非常重要。

首先，这能缩小出错面、提高可靠性。若你对后端 API 做了破坏性修改，客户端代码**必须**更新，否则可能无法理解新数据或会以不兼容格式发送数据。

另一个同样重要的原因与原则 3 的实现有关：若 UI 是自更新的，用户很少会主动刷新页面。在传统网站里，刷新同时完成两件事：重新拉数据、重新拉代码。**只建立推送数据的机制、没有推送代码的机制是不够的**，尤其在一个标签（会话）可能长期不关闭的环境里。

若有服务端推送通道，可以在有新代码时通知客户端；否则可以在发出的 HTTP 请求上附带版本号，由服务端与已知最新版本比较，决定是否处理请求并告知客户端。

之后，部分应用会选择在合适时机替用户刷新页面，例如当页面[不可见](https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API)且没有填写中的表单时。

更好的做法是**热更新代码**：无需整页刷新，在运行时替换某些模块并重新执行其代码。

对很多现有代码库来说，热更新很难实现。值得讨论的是一种把**行为（代码）**与**数据（状态）**清晰分离的架构，这种分离能让各种修补更高效。

例如应用里有一个模块负责事件总线（如 [socket.io](http://socket.io/)）。收到事件后，某组件的状态被填充并渲染到 DOM。若你修改了该组件的行为（例如对已有状态和新状态产出不同的 DOM 结构），理想情况是只更新该组件的代码，而不必重启 socket 连接。因此理想的热更新架构是**模块化**的。

下一项挑战是：模块应能在**不引入不良副作用**的前提下被重新求值。这时 [React](http://facebook.github.io/react/) 这类架构就很有用：若组件代码更新，其逻辑可以简单重新执行，DOM 高效更新。Dan Abramov 对此的探索可[在此](http://gaearon.github.io/react-hot-loader/)看到。

本质在于：**向 DOM 渲染（或“绘制”）** 这一思路大大有利于热更新。若状态保存在 DOM 里，或由应用手动绑定事件监听器，更新代码会复杂得多。

---

## 7. 预测行为

⚡️ 负延迟。

富 JavaScript 应用可以具备**预测用户最终输入**的机制。

最常见的应用是**在动作完成前**就向服务器请求数据。例如在鼠标悬停链接时就开始拉取，这样点击时数据已就绪。

稍进一步是监测鼠标轨迹，分析其与可点击元素（如按钮）的“碰撞”，从而提前触发。[一个 jQuery 示例](https://medium.com/@cihadturhan/a-ux-idea-i-know-where-you-are-aiming-3e00d152afb2)。

---

## 结语

Web 仍是信息传播最多元的媒介之一。在给页面注入更多动态的同时，我们必须保留其历史上的重要优势，并吸收新的能力。

由超链接串联的页面是各类应用的基石。在用户导航过程中**渐进加载**代码、样式和标记，可以在不牺牲交互性的前提下保证良好性能。

JavaScript 带来了新的、独特的机会；一旦被普遍采用，将让这个最开放、最自由的平台达到尽可能好的用户体验。
