# 富 Web 应用的七个原则

**Guillermo Rauch ([@rauchg](https://twitter.com/rauchg))**

2014年11月4日

---

这是基于我在2014年8月BrazilJS大会上的演讲整理的文章。它建立在我最近[博客](https://cloudup.com/blog/the-need-for-speed)[文章](https://cloudup.com/blog/introducing-mydb)中讨论的一些想法之上，主要涉及用户体验和性能。

我想介绍7个可操作的原则，适用于希望使用JavaScript控制UI的网站。这些原则来自我作为Web开发者的经验，也来自我作为万维网长期用户的体验。

JavaScript无疑已成为前端开发者不可或缺的工具。它的使用范围正在扩展到其他领域，如[服务器](http://nodejs.org/)和[微控制器](https://tessel.io/)。它是著名大学[介绍](http://web.stanford.edu/class/cs101/)计算机科学概念的首选语言。

然而，关于它在Web上的精确角色和用法，对许多框架和库的作者来说仍然是个谜。

- JavaScript是否应该用于替代浏览器功能，如历史记录、导航和页面渲染？
- 后端正在消亡吗？我还应该渲染HTML吗？
- 单页应用(SPA)是未来吗？
- JS应该为网站增强页面，但在Web应用中渲染页面吗？
- 是否应该使用PJAX或TurboLinks等技术？
- 网站和Web应用之间的精确区别是什么？应该有区别吗？

以下是我试图回答这些问题的尝试。我的方法是*专门*从用户体验(UX)的角度来审视JavaScript的使用。特别是，我强调最小化用户获取所需数据的时间这一理念。从网络基础知识一直到预测未来。

## 目录

1. [预渲染页面不是可选的](#1-预渲染页面不是可选的)
2. [立即响应用户输入](#2-立即响应用户输入)
3. [响应数据变化](#3-响应数据变化)
4. [控制与服务器的数据交换](#4-控制与服务器的数据交换)
5. [不要破坏历史记录，而是增强它](#5-不要破坏历史记录而是增强它)
6. [推送代码更新](#6-推送代码更新)
7. [预测行为](#7-预测行为)

---

## 1. 预渲染页面不是可选的

> 预渲染不（仅仅）是关于SEO，而是关于性能。考虑获取脚本、样式和后续API请求的额外往返。在未来，考虑HTTP 2.0资源"推送"。

*注意：这个标题以前是"服务器渲染"。然而，"预渲染"也包含[静态站点生成](/2020/2019-in-review#static-is-the-new-dynamic)，所以相应地进行了编辑。*

我首先要指出的是一个相当常见的错误二分法。即"预渲染或服务器渲染应用 vs 单页应用"。如果我们想优化最佳用户体验和性能，放弃任何一方都不是好主意。

原因相当简单。页面传输的媒介——互联网——有一个理论速度限制。Stuart Cheshire在著名的文章/吐槽[《是延迟，笨蛋》](http://www.stuartcheshire.org/rants/latency.html)中对此进行了令人难忘的说明：

```
从斯坦福到波士顿的距离是4320公里。
真空中的光速是 300 x 10^6 米/秒。
光纤中的光速大约是真空中光速的66%。
光纤中的光速是 300 x 10^6 米/秒 * 0.66 = 200 x 10^6 米/秒。
到波士顿的单程延迟是 4320公里 / 200 x 10^6 米/秒 = 21.6毫秒。
到波士顿往返的时间是43.2毫秒。
目前从斯坦福到波士顿通过互联网的ping时间约为85毫秒(...)
所以：互联网的硬件目前可以达到光速的两倍以内。
```

引用的斯坦福和波士顿之间85毫秒的往返时间肯定会随着时间的推移而改善，你现在自己的实验可能已经显示出这一点。但重要的是要注意，两个海岸之间的理论最小值约为**50毫秒**。

用户连接的带宽容量可能会明显改善，正如它稳步增长的那样，但延迟指标几乎不会移动。这意味着最小化显示页面信息所需的往返次数对于出色的用户体验和响应性至关重要。

考虑到JavaScript驱动的应用程序的兴起，这一点尤其重要，这些应用程序通常除了`<script>`和`<link>`标签外没有其他标记，只有一个空的`<body>`。这类应用程序被称为"单页应用"或"SPA"。顾名思义，服务器始终只返回一个页面，其余的都由客户端代码处理。

考虑这样一个场景：用户在点击链接或输入URL后导航到`http://app.com/orders/`。当您的应用程序接收并处理请求时，它已经拥有关于该页面将显示什么内容的重要*信息*。例如，它可以预先从数据库获取订单并将其包含在响应中。在大多数SPA的情况下，返回的是一个空白页面和一个`<script>`标签，然后需要另一次往返来获取脚本内容。这样才能再进行另一次往返来获取渲染所需的数据。

此时，许多开发者有意识地接受这种权衡，因为他们确保通过在脚本和样式表响应中发送适当的缓存头，额外的网络跳跃只发生一次。普遍的共识是这是一个可接受的权衡，因为一旦bundle加载完成，你就可以处理大多数用户交互（如转换到其他页面）而无需请求额外的页面或脚本。

然而，即使存在缓存，在考虑脚本解析和评估时间时也有性能损失。[《jQuery对移动设备来说太大了吗？》](http://modernweb.com/2014/03/10/is-jquery-too-big-for-mobile/)描述了仅jQuery一项，对于某些移动浏览器来说，这可能需要数百毫秒。

更糟糕的是，在脚本加载时通常不会给用户任何反馈。这导致显示空白页面，然后突然转换到完全加载的页面。

最重要的是，我们通常忘记了当前互联网数据传输的主要方式(TCP)*开始时很慢*。这几乎保证了大多数脚本bundle不会在一次往返中获取，使上述情况更加糟糕。

TCP连接从握手的初始往返开始。如果你使用SSL（这对于安全的脚本传递很重要），则需要额外两次往返（如果客户端恢复会话则只需一次）。只有这样服务器才能开始发送数据，但事实证明，它是缓慢且逐步地发送的。

TCP协议内置了一种称为*慢启动*的拥塞控制机制，以不断增加的*段*数发送数据。这对SPA有两个严重的影响：

1. **大型脚本的下载时间比看起来要长得多**。正如Ilya Grigorik的书[《高性能浏览器网络》](http://chimera.labs.oreilly.com/books/1230000000545/ch02.html#thats_four_rou)中所解释的，"四次往返(...)和数百毫秒的延迟，才能在客户端和服务器之间达到64 KB的吞吐量"。在这个例子中，考虑伦敦和纽约之间的良好互联网连接，TCP需要225毫秒才能达到最大数据包大小。

2. 由于这条规则也适用于初始页面下载，它使得页面渲染的初始内容变得更加重要。正如Paul Irish在他的演讲[《交付商品》](https://docs.google.com/presentation/d/1MtDBNTH1g7CZzhwlJ1raEJagA8qM3uoV7ta6i66bO2M/present#slide=id.g3eb97ca8f_10)中总结的，**前14kb至关重要**。

在这个窗口内交付内容（即使只是没有数据的基本布局）的网站将显得极其响应迅速。事实上，对于许多快速服务器端应用程序的作者来说，JavaScript被认为是不需要的或应该谨慎使用的。如果应用程序具有快速的后端和数据源，并且服务器靠近用户(CDN)，这种偏见会进一步加强。

服务器在协助和加速内容呈现方面的角色当然是应用程序特定的。解决方案并不总是像"在服务器上渲染整个页面"那样简单。

在某些情况下，与用户可能追求的内容无关的页面部分最好从初始响应中省略，稍后由客户端获取。例如，某些应用程序选择渲染页面的"外壳"以立即响应。然后它们并行获取页面的不同部分。即使在后端服务较慢的情况下，这也能实现出色的响应性。对于某些页面，预渲染"折叠线以上"的内容也是一个可行的选择。

根据服务器拥有的关于会话、用户和URL的信息对脚本和样式进行*定性评估*是绝对关键的。处理排序订单的脚本显然对`/orders`比设置页面的逻辑更重要。也许不那么直观的是，还可以区分"结构性CSS"和"皮肤/主题CSS"。前者可能是JavaScript代码所需的，所以应该阻塞，但后者可以异步加载。

一个不会产生额外往返惩罚的SPA的巧妙例子是一个概念验证的[4096字节的StackOverflow克隆](http://danlec.com/blog/stackoverflow-in-4096-bytes)（理论上可以在TCP连接的第一次握手后往返中交付！）。它通过内联响应中的所有资产来实现这一点，但代价是可缓存性。通过[SPDY或HTTP/2服务器推送](http://www.chromium.org/spdy/link-headers-and-server-hint)，理论上应该可以在单次跳跃中交付可缓存的客户端代码。目前，在服务器上渲染部分或全部页面是避免额外往返的最常见解决方案。

一个足够灵活的系统，可以在浏览器和服务器之间共享渲染代码，并提供逐步加载脚本和样式的工具，可能会消除*网站和网络应用*之间的口语区别。两者都受同样的用户体验原则支配。博客和CRM从根本上没有那么不同。它们有URL、导航，它们向用户显示数据。即使是电子表格应用程序，传统上更依赖客户端功能，首先也需要向用户显示他们有兴趣修改的数据。以最少的网络往返次数做到这一点至关重要。

在我看来，当今许多广泛部署的系统中看到的主要性能权衡与堆栈中复杂性的逐步积累有关。像JavaScript和CSS这样的技术是随着时间的推移添加的。它们的流行程度也随着时间的推移而增加。只有现在我们才能欣赏到它们被应用的不同方式的影响。其中一些通过改进协议来解决（如SPDY和QUIC中看到的持续增强），但大多数好处将来自应用层。

回顾一些关于最初WWW和HTML设计的初始讨论是有帮助的，以便理解这一点。特别是，[这个1997年的邮件列表帖子](http://1997.webhistory.org/www.lists/www-talk.1993q1/0260.html)提议将`<img>`标签添加到HTML中。Marc Andreessen重申了快速提供信息的重要性：

> "如果一个文档必须即时拼凑，它可能会变得任意复杂，即使这受到限制，我们肯定会开始经历以这种方式结构化的文档的主要性能打击。这基本上把**WWW的单跳原则**抛出了门外（好吧，IMG也这样做，但出于非常具体的原因，在非常有限的意义上）——我们确定要这样做吗？"

---

## 2. 立即响应用户输入

> JavaScript允许我们完全掩盖网络延迟。将此作为设计原则应该甚至可以从您的应用程序中删除大多数加载指示器或"正在加载"消息。PJAX或TurboLinks错过了提高速度感知的机会。

第一个原则很大程度上建立在最小化用户与网站交互时延迟的理念之上。

也就是说，无论你在最小化服务器和客户端之间的来回方面投入多少努力，有些事情是你无法控制的。用户和服务器之间的距离给出的理论下限是不可逃避的。

网络质量差或不可预测是另一个重要因素。如果网络连接不好，将发生数据包重传。你期望需要几次往返的可能最终需要好几次。

这就是JavaScript对改善用户体验的最大优势所在。有了客户端代码驱动用户交互，我们现在能够*掩盖延迟*。我们可以创造速度的感知。我们可以人为地接近零延迟。

让我们再考虑一下基本的HTML网页。通过超链接或`<a>`标签连接在一起的文档。当点击其中任何一个时，浏览器将发出一个网络请求，该请求将花费不可预测的时间，然后获取并处理其响应，最后过渡到新状态。

JavaScript允许**立即**和**乐观地**响应用户输入。点击链接或按钮可以导致立即反应，而无需访问网络。一个著名的例子是Gmail（或Google Inbox），归档电子邮件将立即在UI上发生，而服务器请求则异步发送和处理。

在表单的情况下，我们可以在用户提交后立即采取行动，而不是等待某些HTML作为响应。或者更好的是，像Google搜索那样，我们可以响应用户按住键：

这种特定行为是我所说的*布局适应*的一个例子。基本思想是页面的第一个状态"知道"下一个状态的布局，所以它可以在有任何数据填充页面之前过渡到它。它是"乐观的"，因为仍然存在数据永远不会到来而应该显示错误的风险，但这显然是罕见的。

Google的主页与这篇文章特别相关，因为它的演变非常清楚地说明了我们讨论的前两个原则。

首先，分析到`www.google.com`的TCP连接的[数据包转储](https://gist.github.com/rauchg/3e1b2d7529009370b986)表明，他们确保在请求到达后一次性发送整个主页。整个交换，包括关闭连接，对我在旧金山需要64毫秒。这可能自[开始](http://en.wikipedia.org/wiki/Google#mediaviewer/File:Google1998.png)以来一直如此。

2004年底，Google[开创](http://googleblog.blogspot.com/2004/12/ive-got-suggestion.html)使用JavaScript提供内联输入建议（有趣的是，作为一个20%时间项目，像Gmail一样）。这甚至成为[创造AJAX一词](http://www.adaptivepath.com/ideas/ajax-new-approach-web-applications/)的灵感：

> 看看Google Suggest。看看建议的术语是如何随着你输入而更新的，几乎是即时的[...]不需要等待页面重新加载。Google Suggest和Google Maps是我们Adaptive Path一直称之为Ajax的Web应用程序新方法的两个例子

2010年，他们[推出](http://googleblog.blogspot.com/2010/09/search-now-faster-than-speed-of-type.html)了即时搜索，它把JS放在最前面和中心，完全跳过页面刷新，并在你按下键时立即过渡到"搜索结果"布局，如我们上面看到的。

布局适应的另一个突出例子很可能就在你的口袋里。从早期开始，iPhone OS就要求应用作者提供一个`default.png`图像，该图像会立即渲染，而实际应用正在加载。

在这种情况下，操作系统补偿的不一定是网络延迟，而是CPU。考虑到原始硬件的限制，这一点至关重要。然而，有一个场景会打破这种技术。那就是当布局与存储的图像不匹配时，如登录屏幕的情况。[Marco Arment在2010年](http://www.marco.org/2010/11/11/my-default-png-dilemma)对其影响进行了彻底分析。

除了点击和表单提交之外，JavaScript渲染极大地增强了另一种形式的输入——**文件输入**。

我们可以通过各种方式捕获用户的上传意图：拖放、粘贴、文件选择器。然后，多亏了新的[HTML5 API](https://developer.mozilla.org/en-US/docs/Using_files_from_web_applications)，我们可以像已经上传一样显示内容。

在所有这些情况下，我们都在增强速度感知。幸运的是，有大量证据表明这是一个好主意。考虑[这个例子](http://www.nytimes.com/2012/08/19/opinion/sunday/why-waiting-in-line-is-torture.html)，*增加*到行李提取处的步行距离如何减少了休斯顿机场的投诉数量，而不一定使行李处理更快。

这个想法的应用应该对我们应用程序的UI产生非常深远的影响。我认为加载指示器或"正在加载指示器"应该变得罕见，特别是当我们过渡到具有*实时数据*的应用程序时，这将在下一节讨论。

有些情况下，即时性的错觉实际上可能对用户体验有害。考虑支付表单或注销链接。对这些进行乐观操作，告诉用户一切都完成了，而实际上并没有，可能导致负面体验。

但即使在这些情况下，加载指示器的显示也应该**延迟**。它们应该只在用户不再认为响应是即时的之后渲染。根据经常被引用的[Nielsen研究](http://www.nngroup.com/articles/response-times-3-important-limits/)：

> 关于响应时间的基本建议三十年来大致相同 Miller 1968; Card et al. 1991：
> **0.1秒**大约是让用户感觉系统立即反应的极限，这意味着除了显示结果外不需要特殊反馈。
> **1.0秒**大约是用户思维流不被中断的极限，尽管用户会注意到延迟。**通常，超过0.1秒但少于1.0秒的延迟不需要特殊反馈**，但用户确实失去了直接操作数据的感觉。
> **10秒**大约是保持用户注意力集中在对话上的极限。对于更长的延迟，用户将希望在等待计算机完成时执行其他任务

不幸的是，像PJAX或TurboLinks这样的技术在很大程度上错过了本节描述的机会。客户端代码在服务器发生完整往返之前不"知道"页面的未来表示。

---

## 3. 响应数据变化

> 当服务器上的数据发生变化时，让客户端知道而无需询问。这是一种性能改进，使用户免于手动刷新操作（F5、下拉刷新）。新挑战：（重新）连接管理、状态协调。

第三个原则是UI对数据源（通常是一个或多个数据库服务器）中数据变化的*响应性*。

提供一个静态的HTML数据快照，直到用户刷新页面（传统网站）或与之交互（AJAX）正变得越来越过时。

你的UI应该是**自我更新的**。

这在数据点不断增加的世界中至关重要，包括手表、手机、平板电脑和尚未设计的可穿戴设备。

考虑Facebook新闻源在其诞生时，当数据主要通过个人电脑输入时。静态渲染它不是最优的，但如果人们每天最多更新一次他们的个人资料（如果有的话），这是有意义的。

我们现在生活在一个你可以上传照片，让你的同伴几乎立即点赞或评论的世界。由于应用程序的高度并发使用，对实时反馈的需求是自然的。

然而，假设响应性的好处仅限于多用户应用程序是错误的。这就是为什么我喜欢谈论*并发数据*点而不是*用户*。考虑一下将手机上的照片与自己的笔记本电脑共享的常见场景。

将所有暴露给用户的数据视为响应式是有用的。**会话和登录状态同步**是统一应用这一原则的一个例子。如果你的应用程序的用户同时打开多个标签，注销一个将使所有标签失效。这不可避免地增强了隐私和安全性，特别是在多人访问同一设备的情况下。

一旦你设定了屏幕上的信息会自动更新的期望，就需要考虑一个新需求：**状态协调**。

当接收有序的原子数据更新时，很容易忘记你的应用程序应该能够在长时间断开连接后适当更新。考虑关闭笔记本电脑盖子并在几天后重新打开的场景。你的应用程序在那时如何表现？

你的应用程序协调时间上不连续状态的能力也与我们的第一个原则相关。如果你选择在初始页面加载时发送数据，你必须考虑数据在传输中的时间，直到你的客户端脚本加载。这段时间本质上等同于断开连接，而你的脚本的初始连接是会话恢复。

---

## 4. 控制与服务器的数据交换

> 我们现在可以微调与服务器的数据交换。确保处理错误，代表用户重试，在后台同步数据并维护离线缓存。

当WWW被构想时，客户端和服务器之间的数据交换仅限于几种方式：

- 点击链接将`GET`一个新页面并渲染新页面
- 提交表单将`POST`或`GET`并渲染一个新页面
- 嵌入图像或对象将异步`GET`它并渲染它

这种模型的简单性很有吸引力，我们今天在理解数据如何发送和接收方面肯定有更高的学习曲线。

最大的限制是第二点。无法在不一定触发新页面加载的情况下发送数据，从性能角度来看不是最优的。但最重要的是，它完全破坏了后退按钮。

因此，没有JavaScript，Web作为**应用平台**是不可想象的。AJAX在用户提交信息的用户体验方面构成了一个*飞跃*。

我们现在有各种API（`XMLHttpRequest`、`WebSocket`、`EventSource`等），使我们能够对数据流进行精细控制。除了能够发送用户输入到表单中的数据外，我们现在有一些新的机会来增强用户体验。

与我们之前的原则特别相关的一个是能够显示*连接状态*。如果我们设定了数据自动更新的期望，我们应该通知用户*断开连接*和正在进行的*重新连接尝试*。

当检测到断开连接时，将数据存储在内存中（或者更好，`localStorage`）是有用的，这样以后可以发送。考虑到[ServiceWorker](http://jakearchibald.com/2014/using-serviceworker-today/)的引入，这一点尤其重要，它使JavaScript Web应用程序能够在*后台*运行。如果你的应用程序没有打开，你仍然可以尝试在后台同步用户数据。

考虑发送数据时的超时和错误，并**代表用户重试**。如果重新建立连接，尝试再次发送数据。在持续失败的情况下，将其传达给用户。

某些错误应该小心处理。例如，意外的`403`可能意味着用户的会话已失效。在这种情况下，你有机会通过显示登录屏幕来提示用户恢复它。

同样重要的是确保用户不会无意中中断数据流。这可能发生在两种情况下。第一个也是最明显的是关闭浏览器或标签，你可以尝试使用`beforeunload`处理程序来防止。

另一个（不太明显的）是在页面转换发生之前捕获它们，比如点击触发新页面加载的链接。这给你一个机会来显示你自己的模态框。

---

## 5. 不要破坏历史记录，而是增强它

> 没有浏览器为我们管理URL和历史记录，新的挑战出现了。确保不要破坏与滚动相关的期望。保留你自己的缓存以获得快速反馈。

除了表单提交，如果我们只用超链接设计任何现代Web应用程序，我们最终会得到完全功能的后退/前进导航。

例如，考虑典型的"无限分页场景"。实现它的典型方式涉及用JavaScript捕获点击，请求一些数据/HTML，注入它。调用`history.pushState`或`replaceState`是一个可选步骤，不幸的是许多人没有采取。

这就是为什么我使用"破坏"这个词。在Web最初提出的更简单的模型中，这种情况是不存在的。每个状态转换都依赖于URL更改。

另一方面，现在我们可以用JavaScript控制历史记录，增强历史记录的新机会出现了。

其中一个机会是Daniel Pipius所说的[快速返回](https://medium.com/joys-of-javascript/beyond-pushstate-building-single-page-applications-4353246f4480)：

> 返回应该很快；用户不期望数据有太大变化。

这类似于将后退按钮视为应用程序级别的按钮并应用原则*2：立即响应用户输入*。关键是你现在可以决定如何缓存上一页并立即渲染它。然后你可以应用原则3，然后通知用户该页面发生的*新*数据变化。

仍有一些情况你无法控制缓存行为。例如，如果你渲染一个页面，然后导航到第三方网站，用户点击返回。在服务器上渲染HTML然后在客户端修改它的应用程序特别容易受到这个微妙错误的影响。

另一种破坏导航的方式是忽略*滚动记忆*。同样，不依赖JS和手动历史管理的页面很可能不会有这个问题。但动态页面通常会。我测试了网络上两个最流行的JavaScript驱动的新闻源：Twitter和Facebook。两者都表现出*滚动遗忘症*。

最后，注意只在导航历史时相关的状态变化。考虑这个切换评论子树显示的例子。

如果通过在应用程序内跟随链接重新渲染页面，用户的期望可能是所有评论都展开显示。状态是*易失性的*，只与历史堆栈中的条目关联。

---

## 6. 推送代码更新

> 推送数据而不推送代码是不够的。如果你的数据自动更新，你的代码也应该如此。避免API错误并提高性能。使用无状态DOM进行无副作用的重绘。

使你的应用程序响应代码变化至关重要。

首先，它减少了可能错误的表面并增加了可靠性。如果你对后端API进行了破坏性更改，客户端代码*必须*更新。否则它们可能无法理解新数据，或者可能以不兼容的格式发送数据。

另一个同样重要的原因与原则#3的实现有关。如果你的UI是自我更新的，用户就没有理由触发页面刷新。

请记住，在传统网站中，页面刷新完成两件事：重新加载数据和重新加载代码。建立推送数据的机制而没有推送代码的机制是不够的，特别是在一个标签（会话）可能打开很长时间的世界里。

如果服务器推送通道到位，可以在新代码可用时向客户端发出通知。在没有这种情况下，可以将版本号作为头附加到传出的HTTP请求中。然后服务器可以将其与已知的最新版本进行比较，选择处理请求与否，并建议客户端。

在此之后，一些Web应用程序选择在认为适当时代表用户刷新页面。例如，如果页面[不可见](https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API)且没有填写表单输入。

更好的方法是执行**热代码重载**。这意味着不需要执行完整的页面刷新。相反，某些模块可以即时交换，其代码重新执行。

使热代码重载对许多现有代码库起作用当然很难。因此值得讨论一种优雅地将*行为*（代码）与*数据*（状态）分开的架构类型。这种分离将允许我们使许多不同的补丁非常高效。

例如，考虑应用程序中设置事件总线的模块（例如：[socket.io](http://socket.io/)）。当接收到事件时，某个组件的状态被填充并渲染到DOM。然后你修改该组件的行为，例如，使其为现有和新状态产生不同的DOM标记。

理想的场景是我们能够在每个模块的基础上更新代码。例如，如果我们只更新修改后的组件的代码就够了，那么重新启动socket连接就没有意义。因此，我们热代码推送的理想架构是*模块化*的。

但下一个挑战是模块应该能够重新评估而不引入不良副作用。这就是像[React](http://facebook.github.io/react/)提出的架构特别方便的地方。如果组件代码被更新，其逻辑可以轻松地重新执行，DOM高效更新。Dan Abramov对这个概念的探索可以[在这里找到](http://gaearon.github.io/react-hot-loader/)。

本质上，你*渲染到*DOM（或*绘制*它）的想法是显著帮助热代码交换的原因。如果状态保存在DOM中，或者事件监听器是由你的应用程序手动设置的，更新代码将成为一个更加复杂的任务。

---

## 7. 预测行为

> 负延迟。

丰富的JavaScript应用程序可以有适当的机制来预测*最终的用户输入*。

这个想法最常见的应用是在动作完成之前预先从服务器请求数据。当你悬停在超链接上时开始获取数据，以便在点击时准备就绪，这是一个直接的例子。

一种稍微更高级的方法是监视鼠标移动并分析其轨迹以检测与可操作元素（如按钮）的"碰撞"。

---

## 结论

Web仍然是信息传输最通用的媒介之一。随着我们继续为页面添加更多动态性，我们必须确保保留其一些伟大的历史优势，同时融入新的优势。

通过超链接相互连接的页面是任何类型应用程序的良好构建块。随着用户浏览，代码、样式和标记的渐进加载将确保出色的性能，而不牺牲交互性。

JavaScript已经启用了新的独特机会，一旦普遍采用，将确保现有最广泛和最自由的平台上最佳的用户体验。

---

**原文作者**: Guillermo Rauch ([@rauchg](https://twitter.com/rauchg))

**原文链接**: https://rauchg.com/2014/7-principles-of-rich-web-applications

**原文日期**: 2014年11月4日
